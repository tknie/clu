// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// AddViewParams is parameters of addView operation.
type AddViewParams struct {
	// Database URL.
	URL string
	// Database file number.
	File int
}

func unpackAddViewParams(packed middleware.Parameters) (params AddViewParams) {
	{
		key := middleware.ParameterKey{
			Name: "url",
			In:   "query",
		}
		params.URL = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "file",
			In:   "query",
		}
		params.File = packed[key].(int)
	}
	return params
}

func decodeAddViewParams(args [0]string, argsEscaped bool, r *http.Request) (params AddViewParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: url.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "url",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.URL = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "url",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: file.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "file",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.File = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// BatchParameterQueryParams is parameters of batchParameterQuery operation.
type BatchParameterQueryParams struct {
	// Batch name.
	Table string
	// SQL statement.
	Query string
	// Check for validator additional information needed to be given to validator plugin.
	Validate OptString `json:",omitempty,omitzero"`
}

func unpackBatchParameterQueryParams(packed middleware.Parameters) (params BatchParameterQueryParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "query",
			In:   "path",
		}
		params.Query = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "validate",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Validate = v.(OptString)
		}
	}
	return params
}

func decodeBatchParameterQueryParams(args [2]string, argsEscaped bool, r *http.Request) (params BatchParameterQueryParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: query.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "query",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Query = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "query",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: validate.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "validate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotValidateVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotValidateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Validate.SetTo(paramsDotValidateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "validate",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// BatchQueryParams is parameters of batchQuery operation.
type BatchQueryParams struct {
	// Batch name.
	Table string
	// Check for validator additional information needed to be given to validator plugin.
	Validate OptString `json:",omitempty,omitzero"`
}

func unpackBatchQueryParams(packed middleware.Parameters) (params BatchQueryParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "validate",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Validate = v.(OptString)
		}
	}
	return params
}

func decodeBatchQueryParams(args [1]string, argsEscaped bool, r *http.Request) (params BatchQueryParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: validate.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "validate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotValidateVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotValidateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Validate.SetTo(paramsDotValidateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "validate",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// BatchSelectParams is parameters of batchSelect operation.
type BatchSelectParams struct {
	// Query parameter.
	Param []string `json:",omitempty"`
	// Batch name.
	Table string
	// Check for validator additional information needed to be given to validator plugin.
	Validate OptString `json:",omitempty,omitzero"`
}

func unpackBatchSelectParams(packed middleware.Parameters) (params BatchSelectParams) {
	{
		key := middleware.ParameterKey{
			Name: "param",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Param = v.([]string)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "validate",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Validate = v.(OptString)
		}
	}
	return params
}

func decodeBatchSelectParams(args [1]string, argsEscaped bool, r *http.Request) (params BatchSelectParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: param.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "param",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotParamVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotParamVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Param = append(params.Param, paramsDotParamVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "param",
			In:   "query",
			Err:  err,
		}
	}
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: validate.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "validate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotValidateVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotValidateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Validate.SetTo(paramsDotValidateVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "validate",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// BrowseLocationParams is parameters of browseLocation operation.
type BrowseLocationParams struct {
	// Identifier of the file location.
	Path string
	// Filter the result set.
	Filter OptString `json:",omitempty,omitzero"`
}

func unpackBrowseLocationParams(packed middleware.Parameters) (params BrowseLocationParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "filter",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Filter = v.(OptString)
		}
	}
	return params
}

func decodeBrowseLocationParams(args [1]string, argsEscaped bool, r *http.Request) (params BrowseLocationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: filter.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "filter",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// CallExtendParams is parameters of callExtend operation.
type CallExtendParams struct {
	// Identifier of the file location.
	Path   string
	Params *CallExtendParams
}

func unpackCallExtendParams(packed middleware.Parameters) (params CallExtendParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "params",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Params = v.(*CallExtendParams)
		}
	}
	return params
}

func decodeCallExtendParams(args [1]string, argsEscaped bool, r *http.Request) (params CallExtendParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: params.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "params",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotParamsVal CallExtendParams
				if err := func() error {
					return paramsDotParamsVal.DecodeURI(d)
				}(); err != nil {
					return err
				}
				params.Params = &paramsDotParamsVal
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "params",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// CallPostExtendParams is parameters of callPostExtend operation.
type CallPostExtendParams struct {
	// Identifier of the file location.
	Path string
	// Identifier of the file location.
	File string
}

func unpackCallPostExtendParams(packed middleware.Parameters) (params CallPostExtendParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "file",
			In:   "query",
		}
		params.File = packed[key].(string)
	}
	return params
}

func decodeCallPostExtendParams(args [1]string, argsEscaped bool, r *http.Request) (params CallPostExtendParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: file.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "file",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.File = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// CreateDirectoryParams is parameters of createDirectory operation.
type CreateDirectoryParams struct {
	// Identifier of the file location.
	Path string
}

func unpackCreateDirectoryParams(packed middleware.Parameters) (params CreateDirectoryParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	return params
}

func decodeCreateDirectoryParams(args [1]string, argsEscaped bool, r *http.Request) (params CreateDirectoryParams, _ error) {
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteExtendParams is parameters of deleteExtend operation.
type DeleteExtendParams struct {
	// Identifier of the file location.
	Path string
	// Identifier of the file location.
	File string
}

func unpackDeleteExtendParams(packed middleware.Parameters) (params DeleteExtendParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "file",
			In:   "query",
		}
		params.File = packed[key].(string)
	}
	return params
}

func decodeDeleteExtendParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteExtendParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: file.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "file",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.File = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteFileLocationParams is parameters of deleteFileLocation operation.
type DeleteFileLocationParams struct {
	// Identifier of the file location.
	Path string
	// Identifier of the file location.
	File OptString `json:",omitempty,omitzero"`
}

func unpackDeleteFileLocationParams(packed middleware.Parameters) (params DeleteFileLocationParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "file",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.File = v.(OptString)
		}
	}
	return params
}

func decodeDeleteFileLocationParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteFileLocationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: file.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "file",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFileVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFileVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.File.SetTo(paramsDotFileVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteJobResultParams is parameters of deleteJobResult operation.
type DeleteJobResultParams struct {
	// Job name to be requested.
	JobName string
	// Job id of execution result to be requested.
	JobId string
}

func unpackDeleteJobResultParams(packed middleware.Parameters) (params DeleteJobResultParams) {
	{
		key := middleware.ParameterKey{
			Name: "jobName",
			In:   "path",
		}
		params.JobName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "jobId",
			In:   "path",
		}
		params.JobId = packed[key].(string)
	}
	return params
}

func decodeDeleteJobResultParams(args [2]string, argsEscaped bool, r *http.Request) (params DeleteJobResultParams, _ error) {
	// Decode path: jobName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "jobName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.JobName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "jobName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: jobId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "jobId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.JobId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "jobId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteRecordsSearchedParams is parameters of deleteRecordsSearched operation.
type DeleteRecordsSearchedParams struct {
	// Start offset where the read will start from.
	Start OptFloat64 `json:",omitempty,omitzero"`
	// Maximal number of records retrieved.
	Limit OptString `json:",omitempty,omitzero"`
	// Sort criterium.
	SortedBy OptString `json:",omitempty,omitzero"`
	// Search criterium.
	Sqlsearch OptString `json:",omitempty,omitzero"`
	// Return result in compact structure.
	Compact OptBool `json:",omitempty,omitzero"`
	// Remove database group tree entries in result records.
	Flatten OptBool `json:",omitempty,omitzero"`
	// Read a descriptor read with the given field entry.
	Descriptor OptBool `json:",omitempty,omitzero"`
	// Order by criterias.
	Orderby OptString `json:",omitempty,omitzero"`
	// Use XML notation namespace.
	Xmlnotation OptBool `json:",omitempty,omitzero"`
	// SQL table.
	Table string
	// Specific SQL query string.
	Search string
}

func unpackDeleteRecordsSearchedParams(packed middleware.Parameters) (params DeleteRecordsSearchedParams) {
	{
		key := middleware.ParameterKey{
			Name: "start",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Start = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sorted_by",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SortedBy = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sqlsearch",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sqlsearch = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "compact",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Compact = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "flatten",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Flatten = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "descriptor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Descriptor = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "orderby",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Orderby = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "xmlnotation",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Xmlnotation = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	return params
}

func decodeDeleteRecordsSearchedParams(args [2]string, argsEscaped bool, r *http.Request) (params DeleteRecordsSearchedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: start.
	{
		val := float64(0)
		params.Start.SetTo(val)
	}
	// Decode query: start.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Start.SetTo(paramsDotStartVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Start.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := string("15")
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sorted_by.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sorted_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortedByVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortedByVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SortedBy.SetTo(paramsDotSortedByVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sorted_by",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sqlsearch.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sqlsearch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSqlsearchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSqlsearchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sqlsearch.SetTo(paramsDotSqlsearchVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sqlsearch",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: compact.
	{
		val := bool(false)
		params.Compact.SetTo(val)
	}
	// Decode query: compact.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "compact",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCompactVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotCompactVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Compact.SetTo(paramsDotCompactVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "compact",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: flatten.
	{
		val := bool(false)
		params.Flatten.SetTo(val)
	}
	// Decode query: flatten.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "flatten",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFlattenVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotFlattenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Flatten.SetTo(paramsDotFlattenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "flatten",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: descriptor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "descriptor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDescriptorVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotDescriptorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Descriptor.SetTo(paramsDotDescriptorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "descriptor",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: orderby.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "orderby",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderbyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderbyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Orderby.SetTo(paramsDotOrderbyVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "orderby",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: xmlnotation.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "xmlnotation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXmlnotationVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotXmlnotationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Xmlnotation.SetTo(paramsDotXmlnotationVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "xmlnotation",
			In:   "query",
			Err:  err,
		}
	}
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteViewParams is parameters of deleteView operation.
type DeleteViewParams struct {
	// Database URL.
	URL string
	// Database file number.
	File int
}

func unpackDeleteViewParams(packed middleware.Parameters) (params DeleteViewParams) {
	{
		key := middleware.ParameterKey{
			Name: "url",
			In:   "query",
		}
		params.URL = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "file",
			In:   "query",
		}
		params.File = packed[key].(int)
	}
	return params
}

func decodeDeleteViewParams(args [0]string, argsEscaped bool, r *http.Request) (params DeleteViewParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: url.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "url",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.URL = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "url",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: file.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "file",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.File = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DownloadFileParams is parameters of downloadFile operation.
type DownloadFileParams struct {
	// Identifier of the file location.
	Path string
}

func unpackDownloadFileParams(packed middleware.Parameters) (params DownloadFileParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	return params
}

func decodeDownloadFileParams(args [1]string, argsEscaped bool, r *http.Request) (params DownloadFileParams, _ error) {
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetFieldsParams is parameters of getFields operation.
type GetFieldsParams struct {
	// SQL table.
	Table string
}

func unpackGetFieldsParams(packed middleware.Parameters) (params GetFieldsParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	return params
}

func decodeGetFieldsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetFieldsParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetImageParams is parameters of getImage operation.
type GetImageParams struct {
	// SQL table.
	Table string
	// Remote node reference.
	Reference OptString `json:",omitempty,omitzero"`
	// Specific search.
	Search string
	// Specific the data MIME type.
	Mimetype OptString `json:",omitempty,omitzero"`
	// Specific the field containing the mimetype.
	MimetypeField string
	// Specific the field to be.
	Field string
	// Search criterium.
	Sqlsearch OptString `json:",omitempty,omitzero"`
}

func unpackGetImageParams(packed middleware.Parameters) (params GetImageParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "reference",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Reference = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "mimetype",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Mimetype = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "mimetypeField",
			In:   "query",
		}
		params.MimetypeField = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "field",
			In:   "path",
		}
		params.Field = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "sqlsearch",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sqlsearch = v.(OptString)
		}
	}
	return params
}

func decodeGetImageParams(args [3]string, argsEscaped bool, r *http.Request) (params GetImageParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: reference.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "reference",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotReferenceVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotReferenceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Reference.SetTo(paramsDotReferenceVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "reference",
			In:   "query",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: mimetype.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mimetype",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMimetypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotMimetypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Mimetype.SetTo(paramsDotMimetypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mimetype",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: mimetypeField.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mimetypeField",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MimetypeField = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mimetypeField",
			In:   "query",
			Err:  err,
		}
	}
	// Decode path: field.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "field",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Field = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "field",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: sqlsearch.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sqlsearch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSqlsearchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSqlsearchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sqlsearch.SetTo(paramsDotSqlsearchVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sqlsearch",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetJobExecutionResultParams is parameters of getJobExecutionResult operation.
type GetJobExecutionResultParams struct {
	// Start time from.
	From OptString `json:",omitempty,omitzero"`
	// End time to.
	To OptString `json:",omitempty,omitzero"`
}

func unpackGetJobExecutionResultParams(packed middleware.Parameters) (params GetJobExecutionResultParams) {
	{
		key := middleware.ParameterKey{
			Name: "from",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.From = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "to",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.To = v.(OptString)
		}
	}
	return params
}

func decodeGetJobExecutionResultParams(args [0]string, argsEscaped bool, r *http.Request) (params GetJobExecutionResultParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: from.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFromVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFromVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.From.SetTo(paramsDotFromVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "from",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: to.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotToVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotToVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.To.SetTo(paramsDotToVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "to",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetJobFullInfoParams is parameters of getJobFullInfo operation.
type GetJobFullInfoParams struct {
	// Job Name to be requested.
	JobName string
}

func unpackGetJobFullInfoParams(packed middleware.Parameters) (params GetJobFullInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "jobName",
			In:   "path",
		}
		params.JobName = packed[key].(string)
	}
	return params
}

func decodeGetJobFullInfoParams(args [1]string, argsEscaped bool, r *http.Request) (params GetJobFullInfoParams, _ error) {
	// Decode path: jobName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "jobName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.JobName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "jobName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetJobResultParams is parameters of getJobResult operation.
type GetJobResultParams struct {
	// Job name to be requested.
	JobName string
	// Job id of execution result to be requested.
	JobId string
}

func unpackGetJobResultParams(packed middleware.Parameters) (params GetJobResultParams) {
	{
		key := middleware.ParameterKey{
			Name: "jobName",
			In:   "path",
		}
		params.JobName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "jobId",
			In:   "path",
		}
		params.JobId = packed[key].(string)
	}
	return params
}

func decodeGetJobResultParams(args [2]string, argsEscaped bool, r *http.Request) (params GetJobResultParams, _ error) {
	// Decode path: jobName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "jobName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.JobName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "jobName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: jobId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "jobId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.JobId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "jobId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetJobsParams is parameters of getJobs operation.
type GetJobsParams struct {
	// Timestamp of first job entry.
	StartTime OptString `json:",omitempty,omitzero"`
	// Timestamp of last job entry.
	EndTime OptString `json:",omitempty,omitzero"`
}

func unpackGetJobsParams(packed middleware.Parameters) (params GetJobsParams) {
	{
		key := middleware.ParameterKey{
			Name: "start_time",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartTime = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_time",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndTime = v.(OptString)
		}
	}
	return params
}

func decodeGetJobsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetJobsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: start_time.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartTimeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStartTimeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartTime.SetTo(paramsDotStartTimeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start_time",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end_time.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndTimeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotEndTimeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndTime.SetTo(paramsDotEndTimeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end_time",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetLobByMapParams is parameters of getLobByMap operation.
type GetLobByMapParams struct {
	// Specific the field containing the mimetype.
	MimetypeField OptString `json:",omitempty,omitzero"`
	// Specific the data MIME type.
	Mimetype OptString `json:",omitempty,omitzero"`
	// Search criterium.
	Sqlsearch OptString `json:",omitempty,omitzero"`
	// SQL table.
	Table string
	// Specific table record.
	Search string
	// Specific the field to be.
	Field string
}

func unpackGetLobByMapParams(packed middleware.Parameters) (params GetLobByMapParams) {
	{
		key := middleware.ParameterKey{
			Name: "mimetypeField",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MimetypeField = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "mimetype",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Mimetype = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sqlsearch",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sqlsearch = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "field",
			In:   "path",
		}
		params.Field = packed[key].(string)
	}
	return params
}

func decodeGetLobByMapParams(args [3]string, argsEscaped bool, r *http.Request) (params GetLobByMapParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: mimetypeField.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mimetypeField",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMimetypeFieldVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotMimetypeFieldVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.MimetypeField.SetTo(paramsDotMimetypeFieldVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mimetypeField",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: mimetype.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mimetype",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMimetypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotMimetypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Mimetype.SetTo(paramsDotMimetypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mimetype",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sqlsearch.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sqlsearch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSqlsearchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSqlsearchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sqlsearch.SetTo(paramsDotSqlsearchVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sqlsearch",
			In:   "query",
			Err:  err,
		}
	}
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: field.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "field",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Field = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "field",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetMapMetadataParams is parameters of getMapMetadata operation.
type GetMapMetadataParams struct {
	// SQL table.
	Table string
}

func unpackGetMapMetadataParams(packed middleware.Parameters) (params GetMapMetadataParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	return params
}

func decodeGetMapMetadataParams(args [1]string, argsEscaped bool, r *http.Request) (params GetMapMetadataParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetMapRecordsFieldsParams is parameters of getMapRecordsFields operation.
type GetMapRecordsFieldsParams struct {
	// SQL table.
	Table string
	// Search.
	Search string
	// Specific a comma separated list of fields to be part of the result record.
	Fields string
	// Start offset where the read will start from.
	Start OptFloat64 `json:",omitempty,omitzero"`
	// Maximal number of records retrieved.
	Limit OptString `json:",omitempty,omitzero"`
	// Sort criterium.
	SortedBy OptString `json:",omitempty,omitzero"`
	// Search criterium.
	Sqlsearch OptString `json:",omitempty,omitzero"`
	// Return result in compact structure.
	Compact OptBool `json:",omitempty,omitzero"`
	// Remove database group tree entries in result records.
	Flatten OptBool `json:",omitempty,omitzero"`
	// Read a descriptor read with the given field entry.
	Descriptor OptBool `json:",omitempty,omitzero"`
	// Order by criterias.
	Orderby OptString `json:",omitempty,omitzero"`
	// Use XML notation namespace.
	Xmlnotation OptBool `json:",omitempty,omitzero"`
}

func unpackGetMapRecordsFieldsParams(packed middleware.Parameters) (params GetMapRecordsFieldsParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "fields",
			In:   "path",
		}
		params.Fields = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "start",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Start = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sorted_by",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SortedBy = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sqlsearch",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sqlsearch = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "compact",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Compact = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "flatten",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Flatten = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "descriptor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Descriptor = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "orderby",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Orderby = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "xmlnotation",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Xmlnotation = v.(OptBool)
		}
	}
	return params
}

func decodeGetMapRecordsFieldsParams(args [3]string, argsEscaped bool, r *http.Request) (params GetMapRecordsFieldsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: fields.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "fields",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Fields = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "fields",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: start.
	{
		val := float64(0)
		params.Start.SetTo(val)
	}
	// Decode query: start.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Start.SetTo(paramsDotStartVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Start.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := string("100")
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sorted_by.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sorted_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortedByVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortedByVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SortedBy.SetTo(paramsDotSortedByVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sorted_by",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sqlsearch.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sqlsearch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSqlsearchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSqlsearchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sqlsearch.SetTo(paramsDotSqlsearchVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sqlsearch",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: compact.
	{
		val := bool(false)
		params.Compact.SetTo(val)
	}
	// Decode query: compact.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "compact",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCompactVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotCompactVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Compact.SetTo(paramsDotCompactVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "compact",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: flatten.
	{
		val := bool(false)
		params.Flatten.SetTo(val)
	}
	// Decode query: flatten.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "flatten",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFlattenVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotFlattenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Flatten.SetTo(paramsDotFlattenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "flatten",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: descriptor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "descriptor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDescriptorVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotDescriptorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Descriptor.SetTo(paramsDotDescriptorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "descriptor",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: orderby.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "orderby",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderbyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderbyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Orderby.SetTo(paramsDotOrderbyVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "orderby",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: xmlnotation.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "xmlnotation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXmlnotationVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotXmlnotationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Xmlnotation.SetTo(paramsDotXmlnotationVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "xmlnotation",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetVideoParams is parameters of getVideo operation.
type GetVideoParams struct {
	// SQL table.
	Table string
	// Specific table record number.
	Search string
	// Remote node reference.
	Reference OptString `json:",omitempty,omitzero"`
	// Specific the field to be streamed.
	Field string
	// Specific the field containing the mimetype.
	MimetypeField string
	// MIMEType the result should be of (preferred for some image formats only).
	Mimetype OptString `json:",omitempty,omitzero"`
	// Search criterium.
	Sqlsearch OptString `json:",omitempty,omitzero"`
}

func unpackGetVideoParams(packed middleware.Parameters) (params GetVideoParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "reference",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Reference = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "field",
			In:   "path",
		}
		params.Field = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "mimetypeField",
			In:   "query",
		}
		params.MimetypeField = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "mimetype",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Mimetype = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sqlsearch",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sqlsearch = v.(OptString)
		}
	}
	return params
}

func decodeGetVideoParams(args [3]string, argsEscaped bool, r *http.Request) (params GetVideoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: reference.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "reference",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotReferenceVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotReferenceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Reference.SetTo(paramsDotReferenceVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "reference",
			In:   "query",
			Err:  err,
		}
	}
	// Decode path: field.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "field",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Field = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "field",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: mimetypeField.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mimetypeField",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MimetypeField = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return err
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mimetypeField",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: mimetype.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mimetype",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMimetypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotMimetypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Mimetype.SetTo(paramsDotMimetypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mimetype",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sqlsearch.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sqlsearch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSqlsearchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSqlsearchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sqlsearch.SetTo(paramsDotSqlsearchVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sqlsearch",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// InsertRecordParams is parameters of insertRecord operation.
type InsertRecordParams struct {
	// SQL table.
	Table string
	// Return field result.
	Returning OptString `json:",omitempty,omitzero"`
}

func unpackInsertRecordParams(packed middleware.Parameters) (params InsertRecordParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "returning",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Returning = v.(OptString)
		}
	}
	return params
}

func decodeInsertRecordParams(args [1]string, argsEscaped bool, r *http.Request) (params InsertRecordParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: returning.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "returning",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotReturningVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotReturningVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Returning.SetTo(paramsDotReturningVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "returning",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// SearchModellingParams is parameters of searchModelling operation.
type SearchModellingParams struct {
	// Modelling map and paramters.
	Path string
}

func unpackSearchModellingParams(packed middleware.Parameters) (params SearchModellingParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	return params
}

func decodeSearchModellingParams(args [1]string, argsEscaped bool, r *http.Request) (params SearchModellingParams, _ error) {
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// SearchRecordsFieldsParams is parameters of searchRecordsFields operation.
type SearchRecordsFieldsParams struct {
	// Start offset where the read will start from.
	Start OptFloat64 `json:",omitempty,omitzero"`
	// Maximal number of records retrieved.
	Limit OptString `json:",omitempty,omitzero"`
	// Sort criterium.
	SortedBy OptString `json:",omitempty,omitzero"`
	// Search criterium.
	Sqlsearch OptString `json:",omitempty,omitzero"`
	// Return result in compact structure.
	Compact OptBool `json:",omitempty,omitzero"`
	// Remove database group tree entries in result records.
	Flatten OptBool `json:",omitempty,omitzero"`
	// Read a descriptor read with the given field entry.
	Descriptor OptBool `json:",omitempty,omitzero"`
	// Order by criterias.
	Orderby OptString `json:",omitempty,omitzero"`
	// Use XML notation namespace.
	Xmlnotation OptBool `json:",omitempty,omitzero"`
	// SQL table.
	Table string
	// Specific SQL query string.
	Search string
}

func unpackSearchRecordsFieldsParams(packed middleware.Parameters) (params SearchRecordsFieldsParams) {
	{
		key := middleware.ParameterKey{
			Name: "start",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Start = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sorted_by",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SortedBy = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sqlsearch",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sqlsearch = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "compact",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Compact = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "flatten",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Flatten = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "descriptor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Descriptor = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "orderby",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Orderby = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "xmlnotation",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Xmlnotation = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	return params
}

func decodeSearchRecordsFieldsParams(args [2]string, argsEscaped bool, r *http.Request) (params SearchRecordsFieldsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Set default value for query: start.
	{
		val := float64(0)
		params.Start.SetTo(val)
	}
	// Decode query: start.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Start.SetTo(paramsDotStartVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Start.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := string("15")
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sorted_by.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sorted_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortedByVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortedByVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SortedBy.SetTo(paramsDotSortedByVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sorted_by",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sqlsearch.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sqlsearch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSqlsearchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSqlsearchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sqlsearch.SetTo(paramsDotSqlsearchVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sqlsearch",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: compact.
	{
		val := bool(false)
		params.Compact.SetTo(val)
	}
	// Decode query: compact.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "compact",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCompactVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotCompactVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Compact.SetTo(paramsDotCompactVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "compact",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: flatten.
	{
		val := bool(false)
		params.Flatten.SetTo(val)
	}
	// Decode query: flatten.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "flatten",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFlattenVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotFlattenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Flatten.SetTo(paramsDotFlattenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "flatten",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: descriptor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "descriptor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDescriptorVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotDescriptorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Descriptor.SetTo(paramsDotDescriptorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "descriptor",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: orderby.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "orderby",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderbyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderbyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Orderby.SetTo(paramsDotOrderbyVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "orderby",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: xmlnotation.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "xmlnotation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXmlnotationVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotXmlnotationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Xmlnotation.SetTo(paramsDotXmlnotationVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "xmlnotation",
			In:   "query",
			Err:  err,
		}
	}
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// SearchTableParams is parameters of searchTable operation.
type SearchTableParams struct {
	// SQL table.
	Table string
	// Fields to search for.
	Fields string
	// Search criterium.
	Search string
	// Order by criterias.
	Orderby OptString `json:",omitempty,omitzero"`
}

func unpackSearchTableParams(packed middleware.Parameters) (params SearchTableParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "fields",
			In:   "path",
		}
		params.Fields = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "orderby",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Orderby = v.(OptString)
		}
	}
	return params
}

func decodeSearchTableParams(args [3]string, argsEscaped bool, r *http.Request) (params SearchTableParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: fields.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "fields",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Fields = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "fields",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: orderby.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "orderby",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderbyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderbyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Orderby.SetTo(paramsDotOrderbyVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "orderby",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ShutdownServerParams is parameters of shutdownServer operation.
type ShutdownServerParams struct {
	// Shutdown validation hash.
	Hash string
}

func unpackShutdownServerParams(packed middleware.Parameters) (params ShutdownServerParams) {
	{
		key := middleware.ParameterKey{
			Name: "hash",
			In:   "path",
		}
		params.Hash = packed[key].(string)
	}
	return params
}

func decodeShutdownServerParams(args [1]string, argsEscaped bool, r *http.Request) (params ShutdownServerParams, _ error) {
	// Decode path: hash.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hash",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Hash = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "hash",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// TriggerExtendParams is parameters of triggerExtend operation.
type TriggerExtendParams struct {
	// Identifier of the file location.
	Path string
}

func unpackTriggerExtendParams(packed middleware.Parameters) (params TriggerExtendParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	return params
}

func decodeTriggerExtendParams(args [1]string, argsEscaped bool, r *http.Request) (params TriggerExtendParams, _ error) {
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// TriggerJobParams is parameters of triggerJob operation.
type TriggerJobParams struct {
	// Job Name to be requested.
	JobName string
}

func unpackTriggerJobParams(packed middleware.Parameters) (params TriggerJobParams) {
	{
		key := middleware.ParameterKey{
			Name: "jobName",
			In:   "path",
		}
		params.JobName = packed[key].(string)
	}
	return params
}

func decodeTriggerJobParams(args [1]string, argsEscaped bool, r *http.Request) (params TriggerJobParams, _ error) {
	// Decode path: jobName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "jobName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.JobName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "jobName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateLobByMapParams is parameters of updateLobByMap operation.
type UpdateLobByMapParams struct {
	// SQL table.
	Table string
	// Specific table record.
	Search string
	// Specific the field to be.
	Field string
}

func unpackUpdateLobByMapParams(packed middleware.Parameters) (params UpdateLobByMapParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "field",
			In:   "path",
		}
		params.Field = packed[key].(string)
	}
	return params
}

func decodeUpdateLobByMapParams(args [3]string, argsEscaped bool, r *http.Request) (params UpdateLobByMapParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: field.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "field",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Field = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "field",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateRecordsByFieldsParams is parameters of updateRecordsByFields operation.
type UpdateRecordsByFieldsParams struct {
	// SQL table.
	Table string
	// Specific SQL query string.
	Search string
}

func unpackUpdateRecordsByFieldsParams(packed middleware.Parameters) (params UpdateRecordsByFieldsParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	return params
}

func decodeUpdateRecordsByFieldsParams(args [2]string, argsEscaped bool, r *http.Request) (params UpdateRecordsByFieldsParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UploadFileParams is parameters of uploadFile operation.
type UploadFileParams struct {
	// Identifier of the file location.
	Path string
	// Identifier of the file location.
	File OptString `json:",omitempty,omitzero"`
}

func unpackUploadFileParams(packed middleware.Parameters) (params UploadFileParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "file",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.File = v.(OptString)
		}
	}
	return params
}

func decodeUploadFileParams(args [1]string, argsEscaped bool, r *http.Request) (params UploadFileParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: file.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "file",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFileVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFileVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.File.SetTo(paramsDotFileVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}
