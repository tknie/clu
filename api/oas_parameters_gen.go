// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// AccessParams is parameters of access operation.
type AccessParams struct {
	// Access role information for users or administrators.
	Role AccessRole
}

func unpackAccessParams(packed middleware.Parameters) (params AccessParams) {
	{
		key := middleware.ParameterKey{
			Name: "role",
			In:   "path",
		}
		params.Role = packed[key].(AccessRole)
	}
	return params
}

func decodeAccessParams(args [1]string, argsEscaped bool, r *http.Request) (params AccessParams, _ error) {
	// Decode path: role.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "role",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Role = AccessRole(c)
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := params.Role.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "role",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// AdaptPermissionParams is parameters of adaptPermission operation.
type AdaptPermissionParams struct {
	// SQL table.
	Table string
}

func unpackAdaptPermissionParams(packed middleware.Parameters) (params AdaptPermissionParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	return params
}

func decodeAdaptPermissionParams(args [1]string, argsEscaped bool, r *http.Request) (params AdaptPermissionParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// AddAccessParams is parameters of addAccess operation.
type AddAccessParams struct {
	// Access role information for users or administrators.
	Role AddAccessRole
	// New user to be added.
	User string
}

func unpackAddAccessParams(packed middleware.Parameters) (params AddAccessParams) {
	{
		key := middleware.ParameterKey{
			Name: "role",
			In:   "path",
		}
		params.Role = packed[key].(AddAccessRole)
	}
	{
		key := middleware.ParameterKey{
			Name: "user",
			In:   "query",
		}
		params.User = packed[key].(string)
	}
	return params
}

func decodeAddAccessParams(args [1]string, argsEscaped bool, r *http.Request) (params AddAccessParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: role.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "role",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Role = AddAccessRole(c)
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := params.Role.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "role",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: user.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "user",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.User = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "user",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// AddRBACResourceParams is parameters of addRBACResource operation.
type AddRBACResourceParams struct {
	// SQL table.
	Table string
	// RBAC type.
	Resource AddRBACResourceResource
	// Resource name.
	Name string
}

func unpackAddRBACResourceParams(packed middleware.Parameters) (params AddRBACResourceParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "resource",
			In:   "path",
		}
		params.Resource = packed[key].(AddRBACResourceResource)
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "path",
		}
		params.Name = packed[key].(string)
	}
	return params
}

func decodeAddRBACResourceParams(args [3]string, argsEscaped bool, r *http.Request) (params AddRBACResourceParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: resource.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "resource",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Resource = AddRBACResourceResource(c)
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := params.Resource.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resource",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: name.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// AddViewParams is parameters of addView operation.
type AddViewParams struct {
	// Database URL.
	URL string
	// Database file number.
	File int
}

func unpackAddViewParams(packed middleware.Parameters) (params AddViewParams) {
	{
		key := middleware.ParameterKey{
			Name: "url",
			In:   "query",
		}
		params.URL = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "file",
			In:   "query",
		}
		params.File = packed[key].(int)
	}
	return params
}

func decodeAddViewParams(args [0]string, argsEscaped bool, r *http.Request) (params AddViewParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: url.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "url",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.URL = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "url",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: file.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "file",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.File = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// BatchParameterQueryParams is parameters of batchParameterQuery operation.
type BatchParameterQueryParams struct {
	// Table.
	Table string
	// SQL statement.
	Query string
}

func unpackBatchParameterQueryParams(packed middleware.Parameters) (params BatchParameterQueryParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "query",
			In:   "path",
		}
		params.Query = packed[key].(string)
	}
	return params
}

func decodeBatchParameterQueryParams(args [2]string, argsEscaped bool, r *http.Request) (params BatchParameterQueryParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: query.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "query",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Query = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "query",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// BatchQueryParams is parameters of batchQuery operation.
type BatchQueryParams struct {
	// Table.
	Table string
}

func unpackBatchQueryParams(packed middleware.Parameters) (params BatchQueryParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	return params
}

func decodeBatchQueryParams(args [1]string, argsEscaped bool, r *http.Request) (params BatchQueryParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// BatchSelectParams is parameters of batchSelect operation.
type BatchSelectParams struct {
	// Batch name.
	Table string
	// Query parameter.
	Param []string
}

func unpackBatchSelectParams(packed middleware.Parameters) (params BatchSelectParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "param",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Param = v.([]string)
		}
	}
	return params
}

func decodeBatchSelectParams(args [1]string, argsEscaped bool, r *http.Request) (params BatchSelectParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: param.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "param",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotParamVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotParamVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Param = append(params.Param, paramsDotParamVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "param",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// BrowseLocationParams is parameters of browseLocation operation.
type BrowseLocationParams struct {
	// Identifier of the file location.
	Path string
	// Filter the result set.
	Filter OptString
}

func unpackBrowseLocationParams(packed middleware.Parameters) (params BrowseLocationParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "filter",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Filter = v.(OptString)
		}
	}
	return params
}

func decodeBrowseLocationParams(args [1]string, argsEscaped bool, r *http.Request) (params BrowseLocationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: filter.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFilterVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFilterVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Filter.SetTo(paramsDotFilterVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "filter",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// CallExtendParams is parameters of callExtend operation.
type CallExtendParams struct {
	// Identifier of the file location.
	Path string
	// Parameters.
	Param []string
}

func unpackCallExtendParams(packed middleware.Parameters) (params CallExtendParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "param",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Param = v.([]string)
		}
	}
	return params
}

func decodeCallExtendParams(args [1]string, argsEscaped bool, r *http.Request) (params CallExtendParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: param.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "param",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				return d.DecodeArray(func(d uri.Decoder) error {
					var paramsDotParamVal string
					if err := func() error {
						val, err := d.DecodeValue()
						if err != nil {
							return err
						}

						c, err := conv.ToString(val)
						if err != nil {
							return err
						}

						paramsDotParamVal = c
						return nil
					}(); err != nil {
						return err
					}
					params.Param = append(params.Param, paramsDotParamVal)
					return nil
				})
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "param",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// CallPostExtendParams is parameters of callPostExtend operation.
type CallPostExtendParams struct {
	// Identifier of the file location.
	Path string
	// Identifier of the file location.
	File string
}

func unpackCallPostExtendParams(packed middleware.Parameters) (params CallPostExtendParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "file",
			In:   "query",
		}
		params.File = packed[key].(string)
	}
	return params
}

func decodeCallPostExtendParams(args [1]string, argsEscaped bool, r *http.Request) (params CallPostExtendParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: file.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "file",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.File = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// CreateDirectoryParams is parameters of createDirectory operation.
type CreateDirectoryParams struct {
	// Identifier of the file location.
	Path string
}

func unpackCreateDirectoryParams(packed middleware.Parameters) (params CreateDirectoryParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	return params
}

func decodeCreateDirectoryParams(args [1]string, argsEscaped bool, r *http.Request) (params CreateDirectoryParams, _ error) {
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DatabaseOperationParams is parameters of databaseOperation operation.
type DatabaseOperationParams struct {
	// Database ID optional with operation append with : like 123:shutdown Possible operations are -
	// cancel - shutdown - abort - start.
	TableOperation string
}

func unpackDatabaseOperationParams(packed middleware.Parameters) (params DatabaseOperationParams) {
	{
		key := middleware.ParameterKey{
			Name: "table_operation",
			In:   "path",
		}
		params.TableOperation = packed[key].(string)
	}
	return params
}

func decodeDatabaseOperationParams(args [1]string, argsEscaped bool, r *http.Request) (params DatabaseOperationParams, _ error) {
	// Decode path: table_operation.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table_operation",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TableOperation = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table_operation",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DatabasePostOperationsParams is parameters of databasePostOperations operation.
type DatabasePostOperationsParams struct {
	// Database ID optional with operation append with : like 123:shutdown Possible operations are -
	// cancel - shutdown - abort - start.
	TableOperation string
	// Only used together journal.
	Etsync OptBool
}

func unpackDatabasePostOperationsParams(packed middleware.Parameters) (params DatabasePostOperationsParams) {
	{
		key := middleware.ParameterKey{
			Name: "table_operation",
			In:   "path",
		}
		params.TableOperation = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "etsync",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Etsync = v.(OptBool)
		}
	}
	return params
}

func decodeDatabasePostOperationsParams(args [1]string, argsEscaped bool, r *http.Request) (params DatabasePostOperationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table_operation.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table_operation",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TableOperation = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table_operation",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: etsync.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "etsync",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEtsyncVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotEtsyncVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Etsync.SetTo(paramsDotEtsyncVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "etsync",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DelAccessParams is parameters of delAccess operation.
type DelAccessParams struct {
	// Access role information for users or administrators.
	Role DelAccessRole
	// User to be deleted.
	User string
}

func unpackDelAccessParams(packed middleware.Parameters) (params DelAccessParams) {
	{
		key := middleware.ParameterKey{
			Name: "role",
			In:   "path",
		}
		params.Role = packed[key].(DelAccessRole)
	}
	{
		key := middleware.ParameterKey{
			Name: "user",
			In:   "query",
		}
		params.User = packed[key].(string)
	}
	return params
}

func decodeDelAccessParams(args [1]string, argsEscaped bool, r *http.Request) (params DelAccessParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: role.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "role",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Role = DelAccessRole(c)
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := params.Role.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "role",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: user.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "user",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.User = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "user",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteDatabaseParams is parameters of deleteDatabase operation.
type DeleteDatabaseParams struct {
	// Database ID.
	TableOperation int
}

func unpackDeleteDatabaseParams(packed middleware.Parameters) (params DeleteDatabaseParams) {
	{
		key := middleware.ParameterKey{
			Name: "table_operation",
			In:   "path",
		}
		params.TableOperation = packed[key].(int)
	}
	return params
}

func decodeDeleteDatabaseParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteDatabaseParams, _ error) {
	// Decode path: table_operation.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table_operation",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.TableOperation = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table_operation",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteExtendParams is parameters of deleteExtend operation.
type DeleteExtendParams struct {
	// Identifier of the file location.
	Path string
	// Identifier of the file location.
	File string
}

func unpackDeleteExtendParams(packed middleware.Parameters) (params DeleteExtendParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "file",
			In:   "query",
		}
		params.File = packed[key].(string)
	}
	return params
}

func decodeDeleteExtendParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteExtendParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: file.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "file",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.File = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteFileLocationParams is parameters of deleteFileLocation operation.
type DeleteFileLocationParams struct {
	// Identifier of the file location.
	Path string
	// Identifier of the file location.
	File string
}

func unpackDeleteFileLocationParams(packed middleware.Parameters) (params DeleteFileLocationParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "file",
			In:   "query",
		}
		params.File = packed[key].(string)
	}
	return params
}

func decodeDeleteFileLocationParams(args [1]string, argsEscaped bool, r *http.Request) (params DeleteFileLocationParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: file.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "file",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.File = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteJobResultParams is parameters of deleteJobResult operation.
type DeleteJobResultParams struct {
	// Job name to be requested.
	JobName string
	// Job id of execution result to be requested.
	JobId string
}

func unpackDeleteJobResultParams(packed middleware.Parameters) (params DeleteJobResultParams) {
	{
		key := middleware.ParameterKey{
			Name: "jobName",
			In:   "path",
		}
		params.JobName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "jobId",
			In:   "path",
		}
		params.JobId = packed[key].(string)
	}
	return params
}

func decodeDeleteJobResultParams(args [2]string, argsEscaped bool, r *http.Request) (params DeleteJobResultParams, _ error) {
	// Decode path: jobName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "jobName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.JobName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "jobName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: jobId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "jobId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.JobId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "jobId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteRBACResourceParams is parameters of deleteRBACResource operation.
type DeleteRBACResourceParams struct {
	// SQL table.
	Table string
	// RBAC type.
	Resource DeleteRBACResourceResource
	// Resource name.
	Name string
}

func unpackDeleteRBACResourceParams(packed middleware.Parameters) (params DeleteRBACResourceParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "resource",
			In:   "path",
		}
		params.Resource = packed[key].(DeleteRBACResourceResource)
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "path",
		}
		params.Name = packed[key].(string)
	}
	return params
}

func decodeDeleteRBACResourceParams(args [3]string, argsEscaped bool, r *http.Request) (params DeleteRBACResourceParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: resource.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "resource",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Resource = DeleteRBACResourceResource(c)
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := params.Resource.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resource",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: name.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Name = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteRecordsSearchedParams is parameters of deleteRecordsSearched operation.
type DeleteRecordsSearchedParams struct {
	// SQL table.
	Table string
	// Search.
	Search string
	// Start offset where the read will start from.
	Start OptFloat64
	// Maximal number of records retrieved.
	Limit OptFloat64
	// Sort criterium.
	SortedBy OptString
	// Search criterium.
	Sqlsearch OptString
	// Return result in compact structure.
	Compact OptBool
	// Remove database group tree entries in result records.
	Flatten OptBool
	// Read a descriptor read with the given field entry.
	Descriptor OptBool
	// Order by criterias.
	Orderby OptString
	// Use XML notation namespace.
	Xmlnotation OptBool
}

func unpackDeleteRecordsSearchedParams(packed middleware.Parameters) (params DeleteRecordsSearchedParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "start",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Start = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sorted_by",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SortedBy = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sqlsearch",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sqlsearch = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "compact",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Compact = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "flatten",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Flatten = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "descriptor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Descriptor = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "orderby",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Orderby = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "xmlnotation",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Xmlnotation = v.(OptBool)
		}
	}
	return params
}

func decodeDeleteRecordsSearchedParams(args [2]string, argsEscaped bool, r *http.Request) (params DeleteRecordsSearchedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: start.
	{
		val := float64(0)
		params.Start.SetTo(val)
	}
	// Decode query: start.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Start.SetTo(paramsDotStartVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Start.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := float64(15)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sorted_by.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sorted_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortedByVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortedByVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SortedBy.SetTo(paramsDotSortedByVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sorted_by",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sqlsearch.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sqlsearch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSqlsearchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSqlsearchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sqlsearch.SetTo(paramsDotSqlsearchVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sqlsearch",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: compact.
	{
		val := bool(false)
		params.Compact.SetTo(val)
	}
	// Decode query: compact.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "compact",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCompactVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotCompactVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Compact.SetTo(paramsDotCompactVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "compact",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: flatten.
	{
		val := bool(false)
		params.Flatten.SetTo(val)
	}
	// Decode query: flatten.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "flatten",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFlattenVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotFlattenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Flatten.SetTo(paramsDotFlattenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "flatten",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: descriptor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "descriptor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDescriptorVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotDescriptorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Descriptor.SetTo(paramsDotDescriptorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "descriptor",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: orderby.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "orderby",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderbyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderbyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Orderby.SetTo(paramsDotOrderbyVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "orderby",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: xmlnotation.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "xmlnotation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXmlnotationVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotXmlnotationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Xmlnotation.SetTo(paramsDotXmlnotationVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "xmlnotation",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteViewParams is parameters of deleteView operation.
type DeleteViewParams struct {
	// Database URL.
	URL string
	// Database file number.
	File int
}

func unpackDeleteViewParams(packed middleware.Parameters) (params DeleteViewParams) {
	{
		key := middleware.ParameterKey{
			Name: "url",
			In:   "query",
		}
		params.URL = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "file",
			In:   "query",
		}
		params.File = packed[key].(int)
	}
	return params
}

func decodeDeleteViewParams(args [0]string, argsEscaped bool, r *http.Request) (params DeleteViewParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: url.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "url",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.URL = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "url",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: file.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "file",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.File = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DisconnectTCPParams is parameters of disconnectTCP operation.
type DisconnectTCPParams struct {
	// SQL table.
	Table string
	// First entry of connection ID.
	StartID OptInt
	// Last entry of connection ID.
	EndID OptInt
}

func unpackDisconnectTCPParams(packed middleware.Parameters) (params DisconnectTCPParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "start_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartID = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndID = v.(OptInt)
		}
	}
	return params
}

func decodeDisconnectTCPParams(args [1]string, argsEscaped bool, r *http.Request) (params DisconnectTCPParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: start_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartIDVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotStartIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartID.SetTo(paramsDotStartIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start_id",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndIDVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotEndIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndID.SetTo(paramsDotEndIDVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end_id",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// DownloadFileParams is parameters of downloadFile operation.
type DownloadFileParams struct {
	// Identifier of the file location.
	Path string
}

func unpackDownloadFileParams(packed middleware.Parameters) (params DownloadFileParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	return params
}

func decodeDownloadFileParams(args [1]string, argsEscaped bool, r *http.Request) (params DownloadFileParams, _ error) {
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetConnectionsParams is parameters of getConnections operation.
type GetConnectionsParams struct {
	// SQL table.
	Table string
}

func unpackGetConnectionsParams(packed middleware.Parameters) (params GetConnectionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	return params
}

func decodeGetConnectionsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetConnectionsParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDatabaseSessionsParams is parameters of getDatabaseSessions operation.
type GetDatabaseSessionsParams struct {
	// SQL table.
	Table string
}

func unpackGetDatabaseSessionsParams(packed middleware.Parameters) (params GetDatabaseSessionsParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	return params
}

func decodeGetDatabaseSessionsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDatabaseSessionsParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetDatabaseStatsParams is parameters of getDatabaseStats operation.
type GetDatabaseStatsParams struct {
	// SQL table.
	Table string
}

func unpackGetDatabaseStatsParams(packed middleware.Parameters) (params GetDatabaseStatsParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	return params
}

func decodeGetDatabaseStatsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetDatabaseStatsParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetFieldsParams is parameters of getFields operation.
type GetFieldsParams struct {
	// SQL table.
	Table string
}

func unpackGetFieldsParams(packed middleware.Parameters) (params GetFieldsParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	return params
}

func decodeGetFieldsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetFieldsParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetImageParams is parameters of getImage operation.
type GetImageParams struct {
	// SQL table.
	Table string
	// Remote node reference.
	Reference OptString
	// Specific search.
	Search string
	// Specific the data MIME type.
	Mimetype OptString
	// Specific the field containing the mimetype.
	MimetypeField string
	// Specific the field to be.
	Field string
	// Search criterium.
	Sqlsearch OptString
}

func unpackGetImageParams(packed middleware.Parameters) (params GetImageParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "reference",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Reference = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "mimetype",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Mimetype = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "mimetypeField",
			In:   "query",
		}
		params.MimetypeField = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "field",
			In:   "path",
		}
		params.Field = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "sqlsearch",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sqlsearch = v.(OptString)
		}
	}
	return params
}

func decodeGetImageParams(args [3]string, argsEscaped bool, r *http.Request) (params GetImageParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: reference.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "reference",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotReferenceVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotReferenceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Reference.SetTo(paramsDotReferenceVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "reference",
			In:   "query",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: mimetype.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mimetype",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMimetypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotMimetypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Mimetype.SetTo(paramsDotMimetypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mimetype",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: mimetypeField.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mimetypeField",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MimetypeField = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mimetypeField",
			In:   "query",
			Err:  err,
		}
	}
	// Decode path: field.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "field",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Field = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "field",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: sqlsearch.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sqlsearch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSqlsearchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSqlsearchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sqlsearch.SetTo(paramsDotSqlsearchVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sqlsearch",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetJobExecutionResultParams is parameters of getJobExecutionResult operation.
type GetJobExecutionResultParams struct {
	// Start time from.
	From OptString
	// End time to.
	To OptString
}

func unpackGetJobExecutionResultParams(packed middleware.Parameters) (params GetJobExecutionResultParams) {
	{
		key := middleware.ParameterKey{
			Name: "from",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.From = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "to",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.To = v.(OptString)
		}
	}
	return params
}

func decodeGetJobExecutionResultParams(args [0]string, argsEscaped bool, r *http.Request) (params GetJobExecutionResultParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: from.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFromVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFromVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.From.SetTo(paramsDotFromVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "from",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: to.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotToVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotToVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.To.SetTo(paramsDotToVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "to",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetJobFullInfoParams is parameters of getJobFullInfo operation.
type GetJobFullInfoParams struct {
	// Job Name to be requested.
	JobName string
}

func unpackGetJobFullInfoParams(packed middleware.Parameters) (params GetJobFullInfoParams) {
	{
		key := middleware.ParameterKey{
			Name: "jobName",
			In:   "path",
		}
		params.JobName = packed[key].(string)
	}
	return params
}

func decodeGetJobFullInfoParams(args [1]string, argsEscaped bool, r *http.Request) (params GetJobFullInfoParams, _ error) {
	// Decode path: jobName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "jobName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.JobName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "jobName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetJobResultParams is parameters of getJobResult operation.
type GetJobResultParams struct {
	// Job name to be requested.
	JobName string
	// Job id of execution result to be requested.
	JobId string
}

func unpackGetJobResultParams(packed middleware.Parameters) (params GetJobResultParams) {
	{
		key := middleware.ParameterKey{
			Name: "jobName",
			In:   "path",
		}
		params.JobName = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "jobId",
			In:   "path",
		}
		params.JobId = packed[key].(string)
	}
	return params
}

func decodeGetJobResultParams(args [2]string, argsEscaped bool, r *http.Request) (params GetJobResultParams, _ error) {
	// Decode path: jobName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "jobName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.JobName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "jobName",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: jobId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "jobId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.JobId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "jobId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetJobsParams is parameters of getJobs operation.
type GetJobsParams struct {
	// Timestamp of first job entry.
	StartTime OptString
	// Timestamp of last job entry.
	EndTime OptString
}

func unpackGetJobsParams(packed middleware.Parameters) (params GetJobsParams) {
	{
		key := middleware.ParameterKey{
			Name: "start_time",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.StartTime = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end_time",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.EndTime = v.(OptString)
		}
	}
	return params
}

func decodeGetJobsParams(args [0]string, argsEscaped bool, r *http.Request) (params GetJobsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: start_time.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartTimeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStartTimeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartTime.SetTo(paramsDotStartTimeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start_time",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end_time.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end_time",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndTimeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotEndTimeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndTime.SetTo(paramsDotEndTimeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end_time",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetLobByMapParams is parameters of getLobByMap operation.
type GetLobByMapParams struct {
	// SQL table.
	Table string
	// Specific ISN number.
	Search string
	// Specific the field to be.
	Field string
	// Specific the field containing the mimetype.
	MimetypeField string
	// Specific the data MIME type.
	Mimetype OptString
	// Search criterium.
	Sqlsearch OptString
}

func unpackGetLobByMapParams(packed middleware.Parameters) (params GetLobByMapParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "field",
			In:   "path",
		}
		params.Field = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "mimetypeField",
			In:   "query",
		}
		params.MimetypeField = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "mimetype",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Mimetype = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sqlsearch",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sqlsearch = v.(OptString)
		}
	}
	return params
}

func decodeGetLobByMapParams(args [3]string, argsEscaped bool, r *http.Request) (params GetLobByMapParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: field.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "field",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Field = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "field",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: mimetypeField.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mimetypeField",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MimetypeField = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mimetypeField",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: mimetype.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mimetype",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMimetypeVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotMimetypeVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Mimetype.SetTo(paramsDotMimetypeVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mimetype",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sqlsearch.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sqlsearch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSqlsearchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSqlsearchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sqlsearch.SetTo(paramsDotSqlsearchVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sqlsearch",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetMapMetadataParams is parameters of getMapMetadata operation.
type GetMapMetadataParams struct {
	// SQL table.
	Table string
}

func unpackGetMapMetadataParams(packed middleware.Parameters) (params GetMapMetadataParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	return params
}

func decodeGetMapMetadataParams(args [1]string, argsEscaped bool, r *http.Request) (params GetMapMetadataParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetMapRecordsFieldsParams is parameters of getMapRecordsFields operation.
type GetMapRecordsFieldsParams struct {
	// SQL table.
	Table string
	// Search.
	Search string
	// Specific a comma separated list of fields to be part of the result record.
	Fields string
	// Start offset where the read will start from.
	Start OptFloat64
	// Maximal number of records retrieved.
	Limit OptFloat64
	// Sort criterium.
	SortedBy OptString
	// Search criterium.
	Sqlsearch OptString
	// Return result in compact structure.
	Compact OptBool
	// Remove database group tree entries in result records.
	Flatten OptBool
	// Read a descriptor read with the given field entry.
	Descriptor OptBool
	// Order by criterias.
	Orderby OptString
	// Use XML notation namespace.
	Xmlnotation OptBool
}

func unpackGetMapRecordsFieldsParams(packed middleware.Parameters) (params GetMapRecordsFieldsParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "fields",
			In:   "path",
		}
		params.Fields = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "start",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Start = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sorted_by",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SortedBy = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sqlsearch",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sqlsearch = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "compact",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Compact = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "flatten",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Flatten = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "descriptor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Descriptor = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "orderby",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Orderby = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "xmlnotation",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Xmlnotation = v.(OptBool)
		}
	}
	return params
}

func decodeGetMapRecordsFieldsParams(args [3]string, argsEscaped bool, r *http.Request) (params GetMapRecordsFieldsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: fields.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "fields",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Fields = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "fields",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: start.
	{
		val := float64(0)
		params.Start.SetTo(val)
	}
	// Decode query: start.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Start.SetTo(paramsDotStartVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Start.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := float64(15)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sorted_by.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sorted_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortedByVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortedByVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SortedBy.SetTo(paramsDotSortedByVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sorted_by",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sqlsearch.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sqlsearch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSqlsearchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSqlsearchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sqlsearch.SetTo(paramsDotSqlsearchVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sqlsearch",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: compact.
	{
		val := bool(false)
		params.Compact.SetTo(val)
	}
	// Decode query: compact.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "compact",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCompactVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotCompactVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Compact.SetTo(paramsDotCompactVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "compact",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: flatten.
	{
		val := bool(false)
		params.Flatten.SetTo(val)
	}
	// Decode query: flatten.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "flatten",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFlattenVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotFlattenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Flatten.SetTo(paramsDotFlattenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "flatten",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: descriptor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "descriptor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDescriptorVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotDescriptorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Descriptor.SetTo(paramsDotDescriptorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "descriptor",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: orderby.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "orderby",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderbyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderbyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Orderby.SetTo(paramsDotOrderbyVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "orderby",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: xmlnotation.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "xmlnotation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXmlnotationVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotXmlnotationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Xmlnotation.SetTo(paramsDotXmlnotationVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "xmlnotation",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetPermissionParams is parameters of getPermission operation.
type GetPermissionParams struct {
	// SQL table.
	Table string
	// List type.
	List OptGetPermissionList
}

func unpackGetPermissionParams(packed middleware.Parameters) (params GetPermissionParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "list",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.List = v.(OptGetPermissionList)
		}
	}
	return params
}

func decodeGetPermissionParams(args [1]string, argsEscaped bool, r *http.Request) (params GetPermissionParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: list.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "list",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotListVal GetPermissionList
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotListVal = GetPermissionList(c)
					return nil
				}(); err != nil {
					return err
				}
				params.List.SetTo(paramsDotListVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.List.Get(); ok {
					if err := func() error {
						if err := value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "list",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetVideoParams is parameters of getVideo operation.
type GetVideoParams struct {
	// SQL table.
	Table string
	// Specific ISN number.
	Search string
	// Remote node reference.
	Reference OptString
	// Specific the field to be streamed.
	Field string
	// Specific the field containing the mimetype.
	MimetypeField string
	// MIMEType the result should be of (preferred for some image formats only).
	Mimetype string
	// Search criterium.
	Sqlsearch OptString
}

func unpackGetVideoParams(packed middleware.Parameters) (params GetVideoParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "reference",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Reference = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "field",
			In:   "path",
		}
		params.Field = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "mimetypeField",
			In:   "query",
		}
		params.MimetypeField = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "mimetype",
			In:   "query",
		}
		params.Mimetype = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "sqlsearch",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sqlsearch = v.(OptString)
		}
	}
	return params
}

func decodeGetVideoParams(args [3]string, argsEscaped bool, r *http.Request) (params GetVideoParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: reference.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "reference",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotReferenceVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotReferenceVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Reference.SetTo(paramsDotReferenceVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "reference",
			In:   "query",
			Err:  err,
		}
	}
	// Decode path: field.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "field",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Field = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "field",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: mimetypeField.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mimetypeField",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.MimetypeField = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mimetypeField",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: mimetype.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "mimetype",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Mimetype = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "mimetype",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sqlsearch.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sqlsearch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSqlsearchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSqlsearchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sqlsearch.SetTo(paramsDotSqlsearchVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sqlsearch",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// InsertRecordParams is parameters of insertRecord operation.
type InsertRecordParams struct {
	// SQL table.
	Table string
}

func unpackInsertRecordParams(packed middleware.Parameters) (params InsertRecordParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	return params
}

func decodeInsertRecordParams(args [1]string, argsEscaped bool, r *http.Request) (params InsertRecordParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// ListRBACResourceParams is parameters of listRBACResource operation.
type ListRBACResourceParams struct {
	// SQL table.
	Table string
	// Permission type.
	Resource ListRBACResourceResource
}

func unpackListRBACResourceParams(packed middleware.Parameters) (params ListRBACResourceParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "resource",
			In:   "path",
		}
		params.Resource = packed[key].(ListRBACResourceResource)
	}
	return params
}

func decodeListRBACResourceParams(args [2]string, argsEscaped bool, r *http.Request) (params ListRBACResourceParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: resource.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "resource",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Resource = ListRBACResourceResource(c)
				return nil
			}(); err != nil {
				return err
			}
			if err := func() error {
				if err := params.Resource.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "resource",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// PutDatabaseResourceParams is parameters of putDatabaseResource operation.
type PutDatabaseResourceParams struct {
	// Database ID.
	TableOperation string
	// Database name.
	Name OptString
	// Lock database.
	Lock OptBool
	// External database backup (true=prepare false=continue).
	Externalbackup OptBool
}

func unpackPutDatabaseResourceParams(packed middleware.Parameters) (params PutDatabaseResourceParams) {
	{
		key := middleware.ParameterKey{
			Name: "table_operation",
			In:   "path",
		}
		params.TableOperation = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "name",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Name = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "lock",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Lock = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "externalbackup",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Externalbackup = v.(OptBool)
		}
	}
	return params
}

func decodePutDatabaseResourceParams(args [1]string, argsEscaped bool, r *http.Request) (params PutDatabaseResourceParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table_operation.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table_operation",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TableOperation = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table_operation",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: name.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotNameVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotNameVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Name.SetTo(paramsDotNameVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "name",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: lock.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "lock",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLockVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotLockVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Lock.SetTo(paramsDotLockVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "lock",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: externalbackup.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "externalbackup",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotExternalbackupVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotExternalbackupVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Externalbackup.SetTo(paramsDotExternalbackupVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "externalbackup",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// RemovePermissionParams is parameters of removePermission operation.
type RemovePermissionParams struct {
	// SQL table.
	Table string
}

func unpackRemovePermissionParams(packed middleware.Parameters) (params RemovePermissionParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	return params
}

func decodeRemovePermissionParams(args [1]string, argsEscaped bool, r *http.Request) (params RemovePermissionParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// SearchModellingParams is parameters of searchModelling operation.
type SearchModellingParams struct {
	// Modelling map and paramters.
	Path string
}

func unpackSearchModellingParams(packed middleware.Parameters) (params SearchModellingParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	return params
}

func decodeSearchModellingParams(args [1]string, argsEscaped bool, r *http.Request) (params SearchModellingParams, _ error) {
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// SearchRecordsFieldsParams is parameters of searchRecordsFields operation.
type SearchRecordsFieldsParams struct {
	// SQL table.
	Table string
	// Specific SQL query string.
	Search string
	// Start offset where the read will start from.
	Start OptFloat64
	// Maximal number of records retrieved.
	Limit OptFloat64
	// Sort criterium.
	SortedBy OptString
	// Search criterium.
	Sqlsearch OptString
	// Return result in compact structure.
	Compact OptBool
	// Remove database group tree entries in result records.
	Flatten OptBool
	// Read a descriptor read with the given field entry.
	Descriptor OptBool
	// Order by criterias.
	Orderby OptString
	// Use XML notation namespace.
	Xmlnotation OptBool
}

func unpackSearchRecordsFieldsParams(packed middleware.Parameters) (params SearchRecordsFieldsParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "start",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Start = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptFloat64)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sorted_by",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.SortedBy = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "sqlsearch",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Sqlsearch = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "compact",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Compact = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "flatten",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Flatten = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "descriptor",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Descriptor = v.(OptBool)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "orderby",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Orderby = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "xmlnotation",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Xmlnotation = v.(OptBool)
		}
	}
	return params
}

func decodeSearchRecordsFieldsParams(args [2]string, argsEscaped bool, r *http.Request) (params SearchRecordsFieldsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	// Set default value for query: start.
	{
		val := float64(0)
		params.Start.SetTo(val)
	}
	// Decode query: start.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotStartVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Start.SetTo(paramsDotStartVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Start.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: limit.
	{
		val := float64(15)
		params.Limit.SetTo(val)
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal float64
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToFloat64(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if value, ok := params.Limit.Get(); ok {
					if err := func() error {
						if err := (validate.Float{}).Validate(float64(value)); err != nil {
							return errors.Wrap(err, "float")
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sorted_by.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sorted_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSortedByVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSortedByVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.SortedBy.SetTo(paramsDotSortedByVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sorted_by",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: sqlsearch.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "sqlsearch",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotSqlsearchVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotSqlsearchVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Sqlsearch.SetTo(paramsDotSqlsearchVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "sqlsearch",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: compact.
	{
		val := bool(false)
		params.Compact.SetTo(val)
	}
	// Decode query: compact.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "compact",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotCompactVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotCompactVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Compact.SetTo(paramsDotCompactVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "compact",
			In:   "query",
			Err:  err,
		}
	}
	// Set default value for query: flatten.
	{
		val := bool(false)
		params.Flatten.SetTo(val)
	}
	// Decode query: flatten.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "flatten",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFlattenVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotFlattenVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Flatten.SetTo(paramsDotFlattenVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "flatten",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: descriptor.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "descriptor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotDescriptorVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotDescriptorVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Descriptor.SetTo(paramsDotDescriptorVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "descriptor",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: orderby.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "orderby",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderbyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderbyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Orderby.SetTo(paramsDotOrderbyVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "orderby",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: xmlnotation.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "xmlnotation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotXmlnotationVal bool
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToBool(val)
					if err != nil {
						return err
					}

					paramsDotXmlnotationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Xmlnotation.SetTo(paramsDotXmlnotationVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "xmlnotation",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// SearchTableParams is parameters of searchTable operation.
type SearchTableParams struct {
	// SQL table.
	Table string
	// Fields to search for.
	Fields string
	// Search criterium.
	Search string
	// Order by criterias.
	Orderby OptString
}

func unpackSearchTableParams(packed middleware.Parameters) (params SearchTableParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "fields",
			In:   "path",
		}
		params.Fields = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "orderby",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Orderby = v.(OptString)
		}
	}
	return params
}

func decodeSearchTableParams(args [3]string, argsEscaped bool, r *http.Request) (params SearchTableParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: fields.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "fields",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Fields = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "fields",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: orderby.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "orderby",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOrderbyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotOrderbyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Orderby.SetTo(paramsDotOrderbyVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "orderby",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// ShutdownServerParams is parameters of shutdownServer operation.
type ShutdownServerParams struct {
	// Shutdown validation hash.
	Hash string
}

func unpackShutdownServerParams(packed middleware.Parameters) (params ShutdownServerParams) {
	{
		key := middleware.ParameterKey{
			Name: "hash",
			In:   "path",
		}
		params.Hash = packed[key].(string)
	}
	return params
}

func decodeShutdownServerParams(args [1]string, argsEscaped bool, r *http.Request) (params ShutdownServerParams, _ error) {
	// Decode path: hash.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "hash",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Hash = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "hash",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// TriggerExtendParams is parameters of triggerExtend operation.
type TriggerExtendParams struct {
	// Identifier of the file location.
	Path string
}

func unpackTriggerExtendParams(packed middleware.Parameters) (params TriggerExtendParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	return params
}

func decodeTriggerExtendParams(args [1]string, argsEscaped bool, r *http.Request) (params TriggerExtendParams, _ error) {
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// TriggerJobParams is parameters of triggerJob operation.
type TriggerJobParams struct {
	// Job Name to be requested.
	JobName string
}

func unpackTriggerJobParams(packed middleware.Parameters) (params TriggerJobParams) {
	{
		key := middleware.ParameterKey{
			Name: "jobName",
			In:   "path",
		}
		params.JobName = packed[key].(string)
	}
	return params
}

func decodeTriggerJobParams(args [1]string, argsEscaped bool, r *http.Request) (params TriggerJobParams, _ error) {
	// Decode path: jobName.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "jobName",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.JobName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "jobName",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateLobByMapParams is parameters of updateLobByMap operation.
type UpdateLobByMapParams struct {
	// SQL table.
	Table string
	// Specific ISN number.
	Search string
	// Specific the field to be.
	Field string
}

func unpackUpdateLobByMapParams(packed middleware.Parameters) (params UpdateLobByMapParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "field",
			In:   "path",
		}
		params.Field = packed[key].(string)
	}
	return params
}

func decodeUpdateLobByMapParams(args [3]string, argsEscaped bool, r *http.Request) (params UpdateLobByMapParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[2]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[2])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: field.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "field",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Field = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "field",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateRecordsByFieldsParams is parameters of updateRecordsByFields operation.
type UpdateRecordsByFieldsParams struct {
	// SQL table.
	Table string
	// Fields to check where with.
	Search string
}

func unpackUpdateRecordsByFieldsParams(packed middleware.Parameters) (params UpdateRecordsByFieldsParams) {
	{
		key := middleware.ParameterKey{
			Name: "table",
			In:   "path",
		}
		params.Table = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "search",
			In:   "path",
		}
		params.Search = packed[key].(string)
	}
	return params
}

func decodeUpdateRecordsByFieldsParams(args [2]string, argsEscaped bool, r *http.Request) (params UpdateRecordsByFieldsParams, _ error) {
	// Decode path: table.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "table",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Table = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "table",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: search.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "search",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Search = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "search",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UploadFileParams is parameters of uploadFile operation.
type UploadFileParams struct {
	// Identifier of the file location.
	Path string
	// Identifier of the file location.
	File string
}

func unpackUploadFileParams(packed middleware.Parameters) (params UploadFileParams) {
	{
		key := middleware.ParameterKey{
			Name: "path",
			In:   "path",
		}
		params.Path = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "file",
			In:   "query",
		}
		params.File = packed[key].(string)
	}
	return params
}

func decodeUploadFileParams(args [1]string, argsEscaped bool, r *http.Request) (params UploadFileParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: path.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "path",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Path = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "path",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: file.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "file",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.File = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "file",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}
